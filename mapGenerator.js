
/*
    This class is used to calculate the math arround
    the map generation, such as the voronoi diagram, the perlin map
    and other things
*/
class MapGenerator {
    constructor(gridsize, jitter, width, height) {
        this.gridsize = gridsize
        this.jitter = jitter
        this.width = width
        this.height = height
        this.points = []
        this.widthRatio = width / gridsize
        this.heightRatio = height / gridsize
        this.voronoi = undefined
        this.voronoiDiagram = undefined
        this.polygons = undefined
        this.generatedPolygons = undefined
        this.perlinMap = undefined
        this.perlinPolygons = undefined
        this.heightMap = []
    }

    /*
        This function generate a pseudo-random set of points
        using jitter as pixels offset. The generated points
        is stored in a points array as [..., {x, y}, ...]
    */
    generatePoints() {
        for (let x = 0; x <= this.width; x += this.gridsize) {
            for (let y = 0; y <= this.height; y += this.gridsize) {
                this.points.push({
                    x: x + this.jitter * (Math.random() - Math.random()),
                    y: y + this.jitter * (Math.random() - Math.random())
                })
            }
        }
    }

    /*
        This function calls the perlin.js to generate a new
        Voronoi Diagram with the points array generated above
        The result is stored in diagram
    */
    generateVoronoi() {
        this.voronoi = new Voronoi()
        let bbox = { xl: 0, xr: this.width, yt: 0, yb: this.height }
        this.diagram = this.voronoi.compute(this.points, bbox)
    }

    /*
        Aux function to remove repeated objects in a array using a uniqueKey
        It returns the filtered array
    */
    getUnique(arr, comp) {

        // store the comparison  values in array
        const unique = arr.map(e => e[comp])

            // store the indexes of the unique objects
            .map((e, i, final) => final.indexOf(e) === i && i)

            // eliminate the false indexes & return unique objects
            .filter((e) => arr[e]).map(e => arr[e]);

        return unique;
    }

    /*
        The Fortune's Algorithm can tell with edges makes each cell
        Using this, we can calculate all the polygon generated by
        each cell in the voronoi diagram. To do this, we get all
        the edges, get the edges vertices and then we remove the
        repeated vertices using its product as a key
        We also store de centraPoint (cp) in the array of each cells
        vertices. 
        The output is the polygons array used in drawPolygons
        (see main to see how the function is used)
        THe polygons array is also stored as an attribute
    */
    generatePolygonsFromVoronoiCells() {

        if (this.diagram === undefined) {
            return
        }

        let polygons = []

        this.diagram.cells.forEach((cell) => {
            let polygonVertices = []
            cell['halfedges'].forEach((halfedge) => {
                let vertexAux1 = {
                    x: halfedge['edge']['va'].x,
                    y: halfedge['edge']['va'].y,
                    prod: halfedge['edge']['va'].x * halfedge['edge']['va'].y,
                    cp: cell['site'],
                }
                let vertexAux2 = {
                    x: halfedge['edge']['vb'].x,
                    y: halfedge['edge']['vb'].y,
                    prod: halfedge['edge']['vb'].x * halfedge['edge']['vb'].y,
                    cp: cell['site']
                }

                polygonVertices.push(vertexAux1)
                polygonVertices.push(vertexAux2)

            })
            polygonVertices = this.getUnique(polygonVertices, 'prod')

            polygons.push(polygonVertices)
        })
        this.polygons = polygons
        return polygons
    }

    /*
        Store generated polygons
    */
    assignGeneratedPolygons(generatedPolygons) {
        this.generatedPolygons = generatedPolygons
    }

    /*
        Aux function to clamps a value between a min and max
    */
    map(value, x1, y1, x2, y2) {
        return (value - x1) * (y2 - x2) / (y1 - x1) + x2;
    }

    /*
        Aux function to convert a rgb value to a hex value
    */
    rgbToHex(r, g, b) {
        return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
    }

    /*
        This function creates a new Perlin Noise Map using
        a random seed. After that, get samples of each cells centroid
        to use as reference to paint the polygons later on
    */
    createPerlinNoiseMap(heightMap) {
        perlin.seed(Math.random())
        //console.log(this.generatedPolygons)

        let perlinHexPolygonColor = []
        let gen = new NoiseGenerator('mapa')

        this.generatedPolygons.forEach((polygon) => {
            let perlinPoint = gen.noise(polygon['attrs']['cp'].x, polygon['attrs']['cp'].y)
            //Math.trunc(this.map(perlinPoint, -1, 1, 0, 255))
            //let truncPerlin = Math.trunc(this.map(perlinPoint, -1, 1, 0, 255))
            //let perlinHexBW = this.rgbToHex(truncPerlin, truncPerlin, truncPerlin)
            //console.log(truncPerlin)
            perlinHexPolygonColor.push(perlinPoint)
            //console.log(perlinPoint)
        })

        this.perlinPolygons = perlinHexPolygonColor

        this.assignHeightMap(heightMap)
    }

    assignHeightMap(heightMap) {
        //console.log(heightMap)
        //console.log(this.perlinPolygons)
        let auxArray = []
        this.perlinPolygons.forEach((element) => {
            auxArray.push(heightMap.getColorFromHeight(element))
            //console.log(auxArray)
        })
        this.perlinPolygons = auxArray
    }

}

