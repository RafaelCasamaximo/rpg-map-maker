
/*
    The MapEditor class is responsible for adding new elements to the canvas,
    managing the stage, layers and groups. It also has the main function which
    is the code base. It's important to keep this function clean and short.
*/
class MapEditor {
    constructor(divId, width, height) {

        //General Attributes
        this.divId = divId
        this.width = width
        this.height = height
        this.layers = []

        //Stage startup
        this.stage = null
        this.stage = new Konva.Stage({
            container: divId,   // id of container <div>
            width: width,
            height: height,
            draggable: true,
        });
    }

    /*
        Create a new layer with Konva
        Push the new layer to the layers array in a object {name, layer}
        Returns the layer
    */
    createNewLayer(name) {
        let newLayer = new Konva.Layer();
        this.layers.push({ name: name, layer: newLayer })
        return newLayer
    }

    /*
        Loop all layers and add them to the stage
    */
    addLayersToStage() {
        this.layers.forEach((layerObj) => {
            this.stage.add(layerObj['layer'])
        })
    }

    /*
        Add a shape to a layer using its name
        If the layer name is not found it does not add the shape
    */
    addInLayerByName(name, other) {
        this.layers.forEach((layerObj) => {
            if (layerObj['name'] === name) {
                layerObj['layer'].add(other)
            }
        })
    }

    /* 
        Loop all layers drawing them to the canvas
    */
    drawAllLayers() {
        this.layers.forEach((layerObj) => {
            layerObj['layer'].draw()
        })
    }

    /*
        Recieve a layerName and an array of points as input
        loop through all the points creating new little circles
        in the selected layer.
        If the layer is not found it does not add the points
        the points must be in the format {x,y}
    */
    drawPoints(layerName, points) {
        let selectedLayer = undefined
        this.layers.forEach((layerObj) => {
            if (layerObj['name'] === layerName) {
                selectedLayer = layerObj['layer']
            }
        })

        if (selectedLayer === undefined) {
            return
        }

        points.forEach((point) => {
            let circle = new Konva.Circle({
                x: point.x,
                y: point.y,
                radius: 2,
                fill: 'red',
                stroke: 'black',
                strokeWidth: 1
            });

            selectedLayer.add(circle)
        })
    }

    /*
        An aux function to calculate the orientation of the next point
        when using the convexHull algorithm
    */
    orientation(p, q, r) {
        let val = (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y)
        if (val == 0) {
            return 0
        }
        return (val > 0) ? 1 : 2
    }

    /*
        ConvexHull algorithm: convex hull of a shape is the smallest convex
        set that contains it. It takes a array of points and sort them in
        clockwise direction. It's used to avoid drawing polygons using
        points in the wrong order after calculating the Voronoi Diagram.
        The points array must have the format [..., {x, y, ...}, ...]
        And n must be the length of the array (number of points)
    */
    convexHull(points, n) {
        //If less then 3 vertices, return
        if (n < 3) {
            return
        }

        let hull = []

        let l = 0
        for (let i = 1; i < n; i++) {
            if (points[i].x < points[l].x) {
                l = i
            }
        }

        let p = l
        let q

        do {
            hull.push(points[p])
            q = (p + 1) % n
            for (let i = 0; i < n; i++) {
                if (this.orientation(points[p], points[i], points[q]) == 2) {
                    q = i
                }
            }
            p = q

        } while (p != l)

        return hull
    }

    /*
        Aux function to convert a array in ter format
        [..., {x, y, ...}, ...] to an array of [x1, y1, x2, y2, ...]
        It's used in the konva polygon
    */
    convertVertexArrayToArray(vertexArray) {
        let array = []
        vertexArray.forEach((vertex) => {
            array.push(vertex.x)
            array.push(vertex.y)
        })
        return array
    }

    /*
        Draw all polygons generated by the Voronoi Diagram in
        a layer with layerName. Polygons must be a polygon array
        in a format [..., [..., {x,y, prod, cp}, ....], ...].
        This polygon array is an output from the MapGenerator.
        The mapGenerator object is also used to assign back to the object
        an array of generated polygons.
        It will be used to change the polygons colors later on
    */
    drawPolygons(layerName, polygons, mapGenerator) {
        let selectedLayer = undefined
        this.layers.forEach((layerObj) => {
            if (layerObj['name'] === layerName) {
                selectedLayer = layerObj['layer']
            }
        })

        if (selectedLayer === undefined) {
            return
        }

        let generatedPolygons = []

        polygons.forEach((polygon) => {
            let convHull = this.convexHull(polygon, polygon.length)
            if (polygon.length > 2) {
                let aux = this.convertVertexArrayToArray(convHull)
                let kPolygon = new Konva.Line({
                    points: aux,
                    fill: '#003C5F',
                    opacity: 0.95,
                    stroke: '#00304d',
                    strokeWidth: 1,
                    closed: true,
                    perfectDrawEnabled: false,
                })

                kPolygon.on('mouseover', function () {
                    this.opacity(1);
                });

                kPolygon.on('mouseout', function () {
                    this.opacity(0.95);
                });

                Object.defineProperty(kPolygon['attrs'], 'cp', {
                    value: polygon[0].cp
                })

                generatedPolygons.push(kPolygon)
                selectedLayer.add(kPolygon)
            }
        })

        mapGenerator.assignGeneratedPolygons(generatedPolygons)

    }

    /*
        This function enables the mouse scrolling to zoom in and out
        It calculates the mouse position as the center of the zoom
        and change the canva position and scale using a event listener
    */
    enableMouseScale() {
        let scaleBy = 1.05
        this.stage.on('wheel', (e) => {
            e.evt.preventDefault();
            let oldScale = this.stage.scaleX();
            let pointer = this.stage.getPointerPosition();

            let mousePointTo = {
                x: (pointer.x - this.stage.x()) / oldScale,
                y: (pointer.y - this.stage.y()) / oldScale,
            };

            let newScale = e.evt.deltaY > 0 ? oldScale * scaleBy : oldScale / scaleBy;
            this.stage.scale({ x: newScale, y: newScale });

            let newPos = {
                x: pointer.x - mousePointTo.x * newScale,
                y: pointer.y - mousePointTo.y * newScale,
            };
            this.stage.position(newPos);
        })
    }

    changePolygonsColors(layerName, mapGenerator) {
        let selectedLayer = undefined
        this.layers.forEach((layerObj) => {
            if (layerObj['name'] === layerName) {
                selectedLayer = layerObj['layer']
            }
        })

        if (selectedLayer === undefined) {
            return
        }

        let children = selectedLayer['children']

        children.forEach((child, index) => {
            child.fill(mapGenerator.perlinPolygons[index])
            child.stroke(mapGenerator.perlinPolygons[index])
        })
    }

    /*
        Main function: the base of the program
        It has object instances, value settings and
        function calls without any logic
    */
    main() {
        this.createNewLayer('base')
        this.enableMouseScale()

        let mapGenerator = new MapGenerator(20, 20, this.width, this.height)
        mapGenerator.generatePoints()
        //this.drawPoints('base', mapGenerator.points)

        mapGenerator.generateVoronoi()
        mapGenerator.generatePolygonsFromVoronoiCells()

        this.drawPolygons('base', mapGenerator.polygons, mapGenerator)


        let heightMap = new HeightMap()
        let ocean = heightMap.createNewHeightMap(-1, -0.8, '#0c6687')
        let lowForest = heightMap.createNewHeightMap(-0.8, 0, '#6dc965')
        let forest = heightMap.createNewHeightMap(0, 0.8, '#569437')
        let snow = heightMap.createNewHeightMap(0.8, 1, '#3a6325')
        heightMap.addHeightRange(ocean)
        heightMap.addHeightRange(lowForest)
        heightMap.addHeightRange(forest)
        heightMap.addHeightRange(snow)

        mapGenerator.createPerlinNoiseMap(heightMap)
        this.changePolygonsColors('base', mapGenerator)

        mapGenerator.assignHeightMap(heightMap)

        let toolBox = new ToolBox()
        // toolBox.addButton('newFile', , 'toggle')
        // toolBox.addButton('panTool', , 'toggle')
        //toolBox.addButton('generateLandscape', , 'toggle')
        // toolBox.addButton('increase', , 'toggle')
        // toolBox.addButton('decrease', , 'toggle')
        // toolBox.addButton('save', , 'toggle')

        this.addLayersToStage()
        this.drawAllLayers()
    }

}

/*
    This class is used to calculate the math arround
    the map generation, such as the voronoi diagram, the perlin map
    and other things
*/
class MapGenerator {
    constructor(gridsize, jitter, width, height) {
        this.gridsize = gridsize
        this.jitter = jitter
        this.width = width
        this.height = height
        this.points = []
        this.widthRatio = width / gridsize
        this.heightRatio = height / gridsize
        this.voronoi = undefined
        this.voronoiDiagram = undefined
        this.polygons = undefined
        this.generatedPolygons = undefined
        this.perlinMap = undefined
        this.perlinPolygons = undefined
        this.heightMap = []
    }

    /*
        This function generate a pseudo-random set of points
        using jitter as pixels offset. The generated points
        is stored in a points array as [..., {x, y}, ...]
    */
    generatePoints() {
        for (let x = 0; x <= this.width; x += this.gridsize) {
            for (let y = 0; y <= this.height; y += this.gridsize) {
                this.points.push({
                    x: x + this.jitter * (Math.random() - Math.random()),
                    y: y + this.jitter * (Math.random() - Math.random())
                })
            }
        }
    }

    /*
        This function calls the perlin.js to generate a new
        Voronoi Diagram with the points array generated above
        The result is stored in diagram
    */
    generateVoronoi() {
        this.voronoi = new Voronoi()
        let bbox = { xl: 0, xr: this.width, yt: 0, yb: this.height }
        this.diagram = this.voronoi.compute(this.points, bbox)
    }

    /*
        Aux function to remove repeated objects in a array using a uniqueKey
        It returns the filtered array
    */
    getUnique(arr, comp) {

        // store the comparison  values in array
        const unique = arr.map(e => e[comp])

            // store the indexes of the unique objects
            .map((e, i, final) => final.indexOf(e) === i && i)

            // eliminate the false indexes & return unique objects
            .filter((e) => arr[e]).map(e => arr[e]);

        return unique;
    }

    /*
        The Fortune's Algorithm can tell with edges makes each cell
        Using this, we can calculate all the polygon generated by
        each cell in the voronoi diagram. To do this, we get all
        the edges, get the edges vertices and then we remove the
        repeated vertices using its product as a key
        We also store de centraPoint (cp) in the array of each cells
        vertices. 
        The output is the polygons array used in drawPolygons
        (see main to see how the function is used)
        THe polygons array is also stored as an attribute
    */
    generatePolygonsFromVoronoiCells() {

        if (this.diagram === undefined) {
            return
        }

        let polygons = []

        this.diagram.cells.forEach((cell) => {
            let polygonVertices = []
            cell['halfedges'].forEach((halfedge) => {
                let vertexAux1 = {
                    x: halfedge['edge']['va'].x,
                    y: halfedge['edge']['va'].y,
                    prod: halfedge['edge']['va'].x * halfedge['edge']['va'].y,
                    cp: cell['site'],
                }
                let vertexAux2 = {
                    x: halfedge['edge']['vb'].x,
                    y: halfedge['edge']['vb'].y,
                    prod: halfedge['edge']['vb'].x * halfedge['edge']['vb'].y,
                    cp: cell['site']
                }

                polygonVertices.push(vertexAux1)
                polygonVertices.push(vertexAux2)

            })
            polygonVertices = this.getUnique(polygonVertices, 'prod')

            polygons.push(polygonVertices)
        })
        this.polygons = polygons
        return polygons
    }

    /*
        Store generated polygons
    */
    assignGeneratedPolygons(generatedPolygons) {
        this.generatedPolygons = generatedPolygons
    }

    /*
        Aux function to clamps a value between a min and max
    */
    map(value, x1, y1, x2, y2) {
        return (value - x1) * (y2 - x2) / (y1 - x1) + x2;
    }

    /*
        Aux function to convert a rgb value to a hex value
    */
    rgbToHex(r, g, b) {
        return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
    }

    /*
        This function creates a new Perlin Noise Map using
        a random seed. After that, get samples of each cells centroid
        to use as reference to paint the polygons later on
    */
    createPerlinNoiseMap(heightMap) {
        perlin.seed(Math.random())
        //console.log(this.generatedPolygons)

        let perlinHexPolygonColor = []
        let gen = new NoiseGenerator('mapa')

        this.generatedPolygons.forEach((polygon) => {
            let perlinPoint = gen.noise(polygon['attrs']['cp'].x, polygon['attrs']['cp'].y)
            //Math.trunc(this.map(perlinPoint, -1, 1, 0, 255))
            //let truncPerlin = Math.trunc(this.map(perlinPoint, -1, 1, 0, 255))
            //let perlinHexBW = this.rgbToHex(truncPerlin, truncPerlin, truncPerlin)
            //console.log(truncPerlin)
            perlinHexPolygonColor.push(perlinPoint)
            //console.log(perlinPoint)
        })

        this.perlinPolygons = perlinHexPolygonColor

        this.assignHeightMap(heightMap)
    }

    assignHeightMap(heightMap) {
        //console.log(heightMap)
        //console.log(this.perlinPolygons)
        let auxArray = []
        this.perlinPolygons.forEach((element) => {
            auxArray.push(heightMap.getColorFromHeight(element))
            //console.log(auxArray)
        })
        console.log(auxArray)
        this.perlinPolygons = auxArray
    }

}

class NoiseGenerator {
    constructor(seed = Math.random()) {
        this.gen = new SimplexNoise(seed)
    }

    noise(nx, ny) {
        return this.gen.noise2D(nx, ny)
    }
}

class HeightMap {
    constructor(array = []) {
        this.heightMap = array
        /*
            [
                ...,
                {
                    min: x,
                    max: y,
                    color: 'color'
                },
                ...
            ]
        */
    }

    createNewHeightMap(min, max, color) {
        return {
            min: min,
            max: max,
            color: color
        }
    }

    addHeightRange(heightRangeObj) {
        this.heightMap.push(heightRangeObj)
    }

    getColorFromHeight(height) {
        let color = undefined
        this.heightMap.forEach((element) => {
            if (height >= element['min'] && height < element['max']) {
                color = element['color']
            }
        })
        return (color === undefined) ? '#000000' : color
    }
}


/*
    This class is used to assign function to every button on the toolbox
    using a function array
*/
class ToolBox {
    constructor() {
        this.buttons = []
    }

    /*
        Adds a new button functionality to the buttons array
        needs a divId, a function that is called when clicked
        and a type (that can be click or toggle)
    */
    addButton(divId, execFunction, type = 'click') {
        let button = {
            div: document.getElementById(divId),
            execFunction: execFunction,
            type: type,
            enabled: false,
        }

        button['div'].onclick = function () {
            if (button['type'] === 'toggle') {
                this.buttons.forEach((buttonAux) => {
                    if (buttonAux['type'] === 'toggle') {
                        buttonAux['enabled'] = false
                    }
                })

                button['enabled'] = true
            }

            execFunction()
        }

        this.buttons.push(button)
    }
}

//Create a new mapEditor and call the main function
let mapEditor = new MapEditor('container', innerWidth, innerHeight)
mapEditor.main()

/*
Helpfull links to use as reference
https://github.com/gorhill/Javascript-Voronoi
*/